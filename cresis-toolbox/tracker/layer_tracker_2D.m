function ctrl_chain = layer_tracker_2D(param,param_override)
% set parameters and create tasks in this part. layer_tracker_2D_task will
% then do the actual processing and tuning
% look into sparam and dparam structs for create tasks and also block_size
% for create task for loop. Add settings for viterbi and lsm tracker
%% General Setup
% =====================================================================
param = merge_structs(param, param_override);

%% Input Checks
% =====================================================================
% global gRadar
% param = merge_structs(gRadar,param);

physical_constants;

if ~isfield(param,'layer_tracker') || isempty(param.layer_tracker)
  param.layer_tracker=[];
end

if ~isfield(param.layer_tracker,'debug_plots') || isempty(param.layer_tracker.debug_plots)
  param.layer_tracker.debug_plots = {};
end

% if ~isempty(param.layer_tracker.debug_plots)
%   h_fig = get_figures(1,true);
% end
%
param.layer_tracker.enable_debug_plot = any(strcmp('debug',param.layer_tracker.debug_plots));

% echogram_img: To choose an image besides the base (0) image
if ~isfield(param.layer_tracker,'echogram_img') || isempty(param.layer_tracker.echogram_img)
  param.layer_tracker.echogram_img = 0;
end
%echogram_img = param.layer_tracker.echogram_img;

% echogram source: location of echogram data used for tracking
if ~isfield(param.layer_tracker,'echogram_source') || isempty(param.layer_tracker.echogram_source)
  error('An echogram source must be specified');
end
%echogram_source = param.layer_tracker.echogram_source;

if ~isfield(param.layer_tracker,'layer_params') || isempty(param.layer_tracker.layer_params)
  param.layer_tracker.layer_params = [];
end
%layer_params = param.layer_tracker.layer_params;

%% General Setup Continued
% ======================================================================
%
if isstruct(param.layer_tracker.echogram_source)
  fprintf('  %s: %s (%s)\n', mfilename, 'param.layer_tracker.echogram_source', datestr(now));
else
  fprintf('=====================================================================\n');
  fprintf('%s: %s (%s)\n', mfilename, param.day_seg, datestr(now));
  fprintf('=====================================================================\n');
end

%% Input Checks: track field
% ======================================================================

if ~isfield(param.layer_tracker,'track') || isempty(param.layer_tracker.track)
  param.layer_tracker.track = [];
end


track = merge_structs(param.qlook.surf,param.layer_tracker.track);

% profile: default is no profile, otherwise loads preset configuration
if ~isfield(param.layer_tracker.track,'profile') || isempty(param.layer_tracker.track.profile)
  param.layer_tracker.track.profile = '';
end

track = merge_structs(layer_tracker_profile(param,track.profile), track);

if ~isfield(track,'en') || isempty(track.en)
  % If true, tracking will be done on this segment. If false, then no
  % tracking is done. Default is true.
  track.en = true;
end
if ~track.en
  return;
end

if ~isfield(track,'data_noise_en') || isempty(track.data_noise_en)
  % If true, then a matrix data_noise will be created which will go through
  % all the same operations as data except no "sidelobe" and no "feedthru"
  % masking will be done. This is sometimes necessary to enable when
  % sidelobe or feedthru remove too much data so that the noise estimatation
  % process in the tracker does not function properly. Currently only
  % tracker_threshold makes use of data_noise.
  track.data_noise_en = false;
end

% debug_time_guard: Vertical band around layer in debug plot
if ~isfield(track,'debug_time_guard') || isempty(track.debug_time_guard)
  track.debug_time_guard = 50e-9;
end
param.layer_tracker.debug_time_guard = track.debug_time_guard;

if ~isfield(track,'detrend') || (isempty(track.detrend) && ~ischar(track.detrend))
  track.detrend = 0;
end

if ischar(track.detrend)
  % Load detrend file generated by run_get_echogram_stats
  % e.g. ct_tmp/echogram_stats/snow/2011_Greenland_P3/stats_20110329_02.mat
  if isempty(track.detrend)
    track.detrend = [ct_filename_ct_tmp(param,'','echogram_stats','stats') '.mat'];
  end
  track.detrend_strcut = load(track.detrend,'dt','bins','min_means');
  track.detrend_struct.time = track.detrend_struct.dt*track.detrend_struct.bins;
end

if ~isfield(track,'feedthru') || isempty(track.feedthru)
  track.feedthru = [];
end

if ~isfield(track,'filter') || isempty(track.filter)
  track.filter = [1 1];
end
if length(track.filter) == 1
  warning('Deprecated surf.filter format. Should specify 2 element vector that specifies the multilooks in [cross-track along-track].');
  track.filter = [1 track.filter(1)];
end
if any(mod(track.filter,2) == 0)
  error('Surface filter lengths must be odd. layer_tracker.track.filter = [%d %d].', layer_tracker.track.filter);
end

if ~isfield(track,'filter_trim') || isempty(track.filter_trim)
  track.filter_trim = [0 0];
end

if ~isfield(track,'fixed_value') || isempty(track.fixed_value)
  track.fixed_value = 0;
end

if ~isfield(track,'init') || isempty(track.init)
  track.init = [];
end
if ~isfield(track.init,'method') || isempty(track.init.method)
  track.init.method = 'max';
end
if ~isfield(track.init,'snake_rng') || isempty(track.init.snake_rng)
  track.init.snake_rng = [-2e-7 2e-7];
end
if ~isfield(track.init,'dem_layer') || isempty(track.init.dem_layer)
  track.init.dem_layer = '';
end
if ~any(strcmpi(track.init.method,{'max','nan','snake','medfilt','dem'}))
  error('Unsupported surface init method %s. Options are max, nan, snake, medfilt, or dem. max is default.', track.init.method);
end
if ~isfield(track.init,'max_diff') || isempty(track.init.max_diff)
  track.init.max_diff = inf;
end
if ~isfield(track.init,'max_diff_method') || isempty(track.init.max_diff_method)
  if strcmpi(track.init.method,{'dem'}) || ~isempty(track.init.dem_layer)
    % If the initial surface is from a dem or reference layer, the default
    % method for outliers is to use merge_vectors to fill the outliers in.
    track.init.max_diff_method = 'merge_vectors';
  else
    % Otherwise the default method is just to interpolate between the good
    % points that exist to fill the outliers in.
    track.init.max_diff_method = 'interp_finite';
  end
end
if ~any(strcmpi(track.init.max_diff_method,{'merge_vectors','interp_finite'}))
  error('Unsupported max diff method %s. Options are merge_vectors, interp_finite. The default is interp_finite unless a dem or reference layer is provided.', track.init.max_diff_method);
end

if ~isfield(track,'max_bin') || isempty(track.max_bin)
  track.max_bin = inf;
end

if ~isfield(track,'max_rng') || isempty(track.max_rng)
  track.max_rng = [0 0];
end

if ~isfield(track,'max_rng_units') || isempty(track.max_rng_units)
  track.max_rng_units = 'time';
end

if ~isfield(track,'medfilt') || isempty(track.medfilt)
  % Like medfilt1 except it handles the edges of the frame better
  track.medfilt = 0;
end
if ~isfield(track,'medfilt_threshold') || isempty(track.medfilt_threshold)
  % medfilt_threshold: the point is compared to the medfilt1 result and if
  % the point is > medfilt_threshold from medfilt1, then the point is
  % replaced with the medfilt1 result. The two extremes are:
  %   0 makes medfilt act like medfilt1
  %   inf effectively disables the medfilt operation
  track.medfilt_threshold = 0;
end

if ~isfield(track,'method') || isempty(track.method)
  track.method = '';
end

if ~isfield(track,'min_bin') || isempty(track.min_bin)
  track.min_bin = 0;
end

if ~isfield(track,'prefilter_trim') || isempty(track.prefilter_trim)
  track.prefilter_trim = [0 0];
end

if ~isfield(track,'sidelobe_rows') || isempty(track.sidelobe_rows) || ~isfield(track,'sidelobe_dB') || isempty(track.sidelobe_dB)
  track.sidelobe_dB = [];
  track.sidelobe_rows = [];
end

if ~isfield(track,'snake_rng') || isempty(track.snake_rng)
  track.snake_rng = [-2e-7 2e-7];
end

if ~isfield(track,'threshold') || isempty(track.threshold)
  track.threshold = 15;
end

if ~isfield(track,'threshold_noise_rng') || isempty(track.threshold_noise_rng)
  track.threshold_noise_rng = [0 -inf -1];
end

param.layer_tracker.tracker = track;
%% Load in ocean mask, land DEM, and sea surface DEM
if isfield(track,'init') && strcmpi(track.init.method,'dem')
  global gdem;
  if isempty(gdem) || ~isa(gdem,'dem_class') || ~isvalid(gdem)
    gdem = dem_class(param,500);
  end
  gdem.set_res(500);
  gdem.ocean_mask_mode = 'l';
  
  gdem_str = sprintf('%s:%s:%s',param.radar_name,param.season_name,param.day_seg);
  if ~strcmpi(gdem_str,gdem.name)
    % Load records file
    records_fn = ct_filename_support(param,'','records');
    records = load(records_fn);
    gdem.set_vector(records.lat,records.lon,gdem_str);
  end
end

%% Determine valid frames to process
if nargout ~= 1
  frames = frames_load(param);
  param.cmd.frms = frames_param_cmd_frms(param,frames);
end

% %% Load reference surface
% if isfield(track,'init') && isfield(track.init,'dem_layer') ...
%     && ~isempty(track.init.dem_layer)
%   layers = opsLoadLayers(param,track.init.dem_layer);
%
%   % Ensure that layer gps times are monotonically increasing
%   lay_idx = 1;
%   layers_fieldnames = fieldnames(layers(lay_idx));
%   [~,unique_idxs] = unique(layers(lay_idx).gps_time);
%   for field_idx = 1:length(layers_fieldnames)-1
%     if ~isempty(layers(lay_idx).(layers_fieldnames{field_idx}))
%       layers(lay_idx).(layers_fieldnames{field_idx}) = layers(lay_idx).(layers_fieldnames{field_idx})(unique_idxs);
%     end
%   end
% end


%% Setup Processing
% ====================================================================

[~,~,radar_name] = ct_output_dir(param.radar_name);

records = records_load(param);

% Remove frames that do not exist from param.cmd.frms list
frames = frames_load(param);
param.cmd.frms = frames_param_cmd_frms(param,frames);

% save_name = '/cresis/snfs1/scratch/anjali/CSARP_layerData_Anjali';
% dir_name1 = 'CSARP_layer_tracker_tmp';
% dir_name2 = 'CSARP_layer_tracker';
out_fn_dir = ct_filename_out(param,param.layer_tracker.echogram_source,'');
tmp_out_fn_dir = fullfile(ct_filename_out(param,'layer_tracker_tmp','',1),['CSARP_' param.layer_tracker.track.layer_dest_layerdata_source]);

%% Adding inputs to param

% param.layer_tracker.in_path = ct_filename_out(param,param.layer_tracker.echogram_source,'');


%% Set up Cluster
% ===================================================================

ctrl = cluster_new_batch(param);
%cluster_compile({'layer_tracker_task'},ctrl.cluster.hidden_depend_funs,ctrl.cluster.force_compile,ctrl);
cluster_compile({'layer_tracker_task','layer_tracker_combine_task'},ctrl.cluster.hidden_depend_funs,ctrl.cluster.force_compile,ctrl);
ctrl_chain = {};

%% Create tasks
% sparam, dparam structs, frm loop for frms, ct_proc_frames, cluster_rerun,
% O/P directory, cluster task for block, success condition, create task
%
% sparam.argsin{1}.load.imgs = param.qlook.imgs;
% sparam, dparam, imgs for loop, success condition, rerun mode, create
% task
%
% sparam, dparam, new_task, save_dparam, save_chain, print, cleanup
tmp_out_fn = {};
totalfrms = {};
sparam.argsin{1} = param;
sparam.task_function = 'layer_tracker_task';
sparam.num_args_out = 1;
sparam.argsin{1}.load.echogram_img = param.layer_tracker.echogram_img;
sparam.cpu_time = 60;
sparam.mem = 500e6;
sparam.notes = '';

Nx = 0;
dparam = [];
dparam.file_success = {};
dparam.argsin{1}.frm_nums = [];
param.filename = [];


for frm_idx = 1:param.layer_tracker.N
  frm = param.cmd.frms(frm_idx);
  
  data_fn = fullfile(ct_filename_out(param,param.layer_tracker.echogram_source,''),sprintf('Data_%s_%03d.mat',param.day_seg,frm));
  data = load(data_fn, 'GPS_time','Time');
  if (frm_idx==1)
    max_time = data.Time(end);
    min_time = data.Time(1);
  else
    if(max_time <= data.Time(end))
      max_time = data.Time(end);
    end
    if(min_time >= data.Time(1))
      min_time = data.Time(1);
    end
  end
  Nx = Nx + length(data.GPS_time);
  dt = data.Time(2) - data.Time(1);
end

Nt = min_time:dt:max_time;

%% Create success condition
% ===============================================================

%   dparam.file_success = {};
%   out_fn = fullfile(out_fn_dir,sprintf('Data_%s_%03d.mat',param.day_seg,frm));
%   dparam.file_success{end+1} = out_fn;

switch param.layer_tracker.track.method
  case 'viterbi'
    cpu_time_mult = 100;
    mem_mult = 500e6;
    
  case 'lsm'
    cpu_time_mult = 150;
    mem_mult = 64;
end

dparam.cpu_time = 7000*3; %cpu_time_mult * Nx * length(Nt);
dparam.mem = 500e6*3; %mem_mult * Nx * length(Nt);

%   if ~ctrl.cluster.rerun_only
%     % Mark file for deletion
%     ct_file_lock_check(out_fn,3);
%   end
frm = 1;
%if (N == inf)
%   for frm = 1:length(param.cmd.frms)
%     out_fn = fullfile(out_fn_dir,sprintf('Data_%s_%03d.mat',param.day_seg,frm));
%     dparam.file_success{end+1} = out_fn;
%     dparam.argsin{1}.frm_nums(end+1) = param.cmd.frms;
%     dparam.notes = sprintf('%s:%s:%s:%s %s_%03d (%d of %d)',sparam.task_function,param.radar_name, param.season_name, out_fn_dir, param.day_seg, frm, frm_idx,length(param.cmd.frms));
%   end
%   ctrl = cluster_new_task(ctrl,sparam,dparam,'dparam_save',0);
%else
  %while frm <= length(frames.frame_idxs)
  while frm <= length(frames.frame_idxs)
    for i = 1:param.layer_tracker.N
      if(frm <= 3) %length(frames.frame_idxs))
        out_fn = fullfile(out_fn_dir,sprintf('Data_%s_%03d.mat',param.day_seg,1));
        dparam.notes = sprintf('%s:%s:%s:%s %s_%03d (%d of %d)',sparam.task_function,param.radar_name, param.season_name, out_fn_dir, param.day_seg, 1, 1,length(param.cmd.frms));
        dparam.file_success{end+1} = tmp_out_fn_dir;
        dparam.argsin{1}.frm_nums(end+1) = frm;
        param.filename{end+1} = fullfile(ct_filename_out(param,'layerdata',''),sprintf('Data_%s_%03d.mat', param.day_seg, frm));
        %totalfrms(end+1) = frm;
      end
      frm=frm+1;
    end
    frm_dir = sprintf('layer_tracker_%03d_%03d', dparam.argsin{1}.frm_nums(1),dparam.argsin{1}.frm_nums(end));
    if ~exist(fullfile(tmp_out_fn_dir,frm_dir))
      mkdir(fullfile(tmp_out_fn_dir,frm_dir));
    end
    tmp_out_fn{end+1} = fullfile(tmp_out_fn_dir,frm_dir,sprintf('layer_%s_%s',param.layer_tracker.track.method,param.layer_tracker.name));
    totalfrms{end+1} = [dparam.argsin{1}.frm_nums(1), dparam.argsin{1}.frm_nums(end)];
    %tmp_out_fn.(sprintf('number_frames_%d_%d',dparam.argsin{1}.frm_nums(1),dparam.argsin{1}.frm_nums(end))){end+1} = 
    ctrl = cluster_new_task(ctrl,sparam,dparam,'dparam_save',0);
    dparam.file_success = {};
    
    dparam.argsin{1}.frm_nums = [];
  end
  param.tmp_out_fn = tmp_out_fn;
  param.totalfrms = totalfrms;
  %dparam.argsin{1}.tmp = param;
  
  
%end
%% Rerun only mode: Test to see if we need to run this task
ctrl = cluster_save_dparam(ctrl);
ctrl_chain{end+1} = ctrl;
fprintf('Done %s\n',datestr(now));

%% Combine task
ctrl = cluster_new_batch(param);

sparam = [];
sparam.argsin{1} = param;
sparam.task_function = 'layer_tracker_combine_task';
sparam.num_args_out = 1;

sparam.cpu_time = 7000*3; %cpu_time_mult * Nx * length(Nt);
sparam.mem = 500e6*3; %mem_mult * Nx * length(Nt);
sparam.notes = '';
sparam.file_success = {};
out_fn = fullfile(out_fn_dir,sprintf('Data_%s_%03d.mat',param.day_seg,frm));
sparam.argsin{1}.temp_fn = tmp_out_fn_dir;
%sparam.file_success{end+1} = out_fn;

ctrl = cluster_new_task(ctrl,sparam,[]);
ctrl_chain{end+1} = ctrl;
fprintf('Done %s\n',datestr(now));

