
function [sources_number,doa] = model_order_optimal(doa_mle,Nc,Rxx,Nsnap,bin, model_order_method)

% l: eigen values
[l,index] = sort(eig(Rxx),'descend');

% DCM is symmetric and always we get real eigen values. due to some
% rounding errors in the data generated by matlab we got complex eigen
% values

l = real(l);
l_all(bin,:) = l;
[V,D] = eig(Rxx);
%u: eigen vectors
u = V(:,index);
%normalizing the eigen values
l_norm = l./min(l);               % MIGHT CHANGE THE WAY OF NORMALIZING
l_norm_all(bin,:) = l_norm;




clear MDL_cost log_func penalty

M = Nc-1 ;% max number of sources we are trying to estimate (it can go mupto Nc-1)

for k = 1:M   %%%%CHANGE
  
  sv = exp(1i*pi*sind(doa_mle{k}.')*(0:Nc-1)).';
  
  Proj{k} = sv*(inv(  (sv')*sv ))* (sv') ;
  
  for p_idx = 1:Nc
    term1(k,p_idx) = l_norm(p_idx).*norm(Proj{k}*u(:,p_idx))^2;
  end
  
  log_func(k) = - Nsnap * sum(term1(k,:));
  
  DOF(k) = k*((2*Nc)-k) + 1;  % degree of freedom of the space spanned by signal vectors
  
  
end

log_func = [0 log_func];

DOF = [0 DOF];  % Degrees of freedom


switch model_order_method
  case 0
    %% SRAVYA MDL
    
    
    %         penalty = 10000*([0:Nc-1].^2)*(log(Nsnap)^2);
    penalty = 75*([0:Nc-1].^2)*(log(Nsnap)^2);
    
  case 1
    
    % Minimum descriptive length (MDL)
    penalty = (1/2)*2*DOF*log(Nsnap);
    
    
    
  case 2
    % Akaike information criterion
    penalty = 2*DOF;
    
    
  case 3
    
    % Bayesian information criterion
    penalty = DOF*log(Nsnap);
    
  case 4
    
    
    % Hannan and Quinn criterion
    penalty =  2*DOF*log(log(Nsnap));
    
  case 5
    
    % Corrected AIC
    penalty =  (2*Nsnap.*DOF)./(Nsnap-Nc-[0:M]-1);
    
  case 6
    
    q = 0:Nc-1;
    % Vector corrected Kullback information criterion
    penalty = (Nsnap*Nc*(2.*q+Nc+1))./(Nsnap-Nc-q-1) + (Nsnap*Nc)./(Nsnap-q-((Nc-1)/2))...
      + (2*Nc.*q + Nc*Nc - Nc)./2 ;
  case 7
    
    
    % Weighted-average information criterion
    %         A_tmp = (2*Nsnap.*DOF) ./ (Nsnap-DOF-1);
    %         B_tmp = DOF.*log(Nsnap);
    %         penalty = (A_tmp.^2 + B_tmp.^2) / (A_tmp + B_tmp);
    
    penalty = ((2*Nsnap*DOF).^2 + ((Nsnap-DOF-3).*DOF.*log(Nsnap)).^2 )...
      ./ (2*Nsnap*DOF.*(Nsnap-DOF-3) + (Nsnap-DOF-3).^2 .* DOF*log(Nsnap));
    
  otherwise
    error('Not supported')
end

cost = log_func + penalty;

method_title = ['MDL S'; 'MDL  '; 'AIC  '; 'BIC  '; 'HQ   '; 'AICc '; 'KICvc'; 'WIC  '] ;
%         figure(1);
%         subplot(2,4,model_order_method + 1 )
%         plot(0:M ,cost,'b*-')
%         hold on
%         plot(0:M ,log_func,'g*-')
%         hold on
%         plot(0:M ,penalty,'-r*')
%         legend('MDL cost','log-likelihood','penalty' ,'location', 'east')
%         set(gca,'xtick',0:M)
%         title( method_title(model_order_method+1,:));
%         ylabel('Cost');
%         xlabel('Estimated number of sources (k)');
%         grid on
% hold off
%
%         figure(1);
%
%         plot(0:M ,cost,'b*-')
%         hold on
%         plot(0:M ,log_func,'g*-')
%         hold on
%         plot(0:M ,penalty,'-r*')
%         legend('MDL cost','log-likelihood','penalty' ,'location', 'east')
%         set(gca,'xtick',0:M)
%
%         ylabel('Cost');
%         xlabel('Estimated number of sources (k)');
%         grid on
% hold off

[min_cost, index] = min(cost);
sources_number = index-1;

doa = NaN *ones(1,Nc-1);

if sources_number > 0
  doa(1:sources_number) = doa_mle{sources_number};
end





