function ctrl_chain = master(params,param_override)
% ctrl_chain = master(params,param_override)
%
% Function for processing radar depth sounder data. This function calls all the
% individual processing functions.
%
% IT IS TYPICALLY RUN FROM run_master.m
%
% THIS MASTER RUNS FROM THE PARAM GENERATED BY read_param_xls.m,
% which reads in an excel spread sheet
% (e.g. RADAR_param_YYYY_Mission_Aircraft.xls).
%
% params = struct array of parameters read from read_param_xls
% param_override = parameter structure whos fields will override
%   all fields in params and gRadar (typically used to set the scheduler
%   parameters for this particular run)
%
% gRadar = GLOBAL variable (parameters here are not present in params),
%   These parameters are added to each struct in the params array
%
% Please make a local copy of the excel spread sheet and run_master.
%
% Authors: Brady Maasen, John Paden
%
% See also: run_master

%error('Copy this script locally, remove this line, and then run.\n');

% =====================================================================
% Create param structure array
% =====================================================================
tic;
global gRadar;
fprintf('\n\n========================================================\n\n');

% Input checking
if ~exist('params','var')
  error('Use run_master: A struct array of parameters must be passed in\n');
end
if exist('param_override','var')
  param_override = merge_structs(gRadar,param_override);
else
  param_override = gRadar;
end

% =====================================================================
% =====================================================================
% Process each of the days
% =====================================================================
% =====================================================================
ctrl_chain = {};
for param_idx = 1:length(params)
  param = params(param_idx);
  cmd = param.cmd;
  [output_dir,radar_type,radar_name] = ct_output_dir(param.radar_name);
  new_chain = {};
  
  if isfield(cmd,'create_records') && cmd.create_records
    create_records(param,param_override);
  end
  if isfield(cmd,'qlook') && cmd.qlook
    chain = qlook(param,param_override);
    new_chain = cat(2,new_chain,chain);
  end
  if isfield(cmd,'sar') && cmd.sar
    chain = sar(param,param_override);
    new_chain = cat(2,new_chain,chain);
  end
  if isfield(cmd,'array') && cmd.array
    chain = array(param,param_override);
    new_chain = cat(2,new_chain,chain);
  end
  
  if isfield(cmd,'generic') && (ischar(cmd.generic) || iscell(cmd.generic))
    % This supports all kinds of permutations for running custom commands
    if ischar(cmd.generic)
      % If generic column is string, then enclose in cell
      cmd.generic = {cmd.generic};
    end
    for generic_idx = 1:length(cmd.generic)
      if iscell(cmd.generic{generic_idx})
        % Type 1: Cell Array with rename
        %   Field 1: command to run
        %   Field 2: {worksheets to load, what to rename the worksheet to}
        % Type 2: cell array
        %   field 1: command to run
        %   field 2: worksheet to load
        param = read_param_xls(param.fn,param.day_seg,cmd.generic{generic_idx}{2});
        generic_fh = str2func(cmd.generic{generic_idx}{1});
      else
        % Type 3: String
        %   String contains command to run
        generic_fh = str2func(cmd.generic{generic_idx});
      end
      chain = generic_fh(param,param_override);
      new_chain = cat(2,new_chain,chain);
    end
  end
  
  if ~isempty(new_chain)
    ctrl_chain{end+1} = new_chain;
  end
end

cluster_print_chain(ctrl_chain);

[chain_fn,chain_id] = cluster_save_chain(ctrl_chain);
